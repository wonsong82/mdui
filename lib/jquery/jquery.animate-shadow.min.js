/*
 Shadow animation 1.11
 http://www.bitstorm.org/jquery/shadow-animation/
 Copyright 2011, 2013 Edwin Martin
 Contributors: Mark Carver, Xavier Lepretre and Jason Redding
 Released under the MIT and GPL licenses.
 */
/*
'use strict';jQuery(function(h){function r(b,m,d){var l=[];h.each(b,function(f){var g=[],e=b[f];f=m[f];e.b&&g.push("inset");"undefined"!==typeof f.left&&g.push(parseFloat(e.left+d*(f.left-e.left))+"px "+parseFloat(e.top+d*(f.top-e.top))+"px");"undefined"!==typeof f.blur&&g.push(parseFloat(e.blur+d*(f.blur-e.blur))+"px");"undefined"!==typeof f.a&&g.push(parseFloat(e.a+d*(f.a-e.a))+"px");if("undefined"!==typeof f.color){var p="rgb"+(h.support.rgba?"a":"")+"("+parseInt(e.color[0]+d*(f.color[0]-e.color[0]),
        10)+","+parseInt(e.color[1]+d*(f.color[1]-e.color[1]),10)+","+parseInt(e.color[2]+d*(f.color[2]-e.color[2]),10);h.support.rgba&&(p+=","+parseFloat(e.color[3]+d*(f.color[3]-e.color[3])));g.push(p+")")}l.push(g.join(" "))});return l.join(", ")}function q(b){function m(){var a=/^inset\b/.exec(b.substring(c));return null!==a&&0<a.length?(k.b=!0,c+=a[0].length,!0):!1}function d(){var a=/^(-?[0-9\.]+)(?:px)?\s+(-?[0-9\.]+)(?:px)?(?:\s+(-?[0-9\.]+)(?:px)?)?(?:\s+(-?[0-9\.]+)(?:px)?)?/.exec(b.substring(c));
    return null!==a&&0<a.length?(k.left=parseInt(a[1],10),k.top=parseInt(a[2],10),k.blur=a[3]?parseInt(a[3],10):0,k.a=a[4]?parseInt(a[4],10):0,c+=a[0].length,!0):!1}function l(){var a=/^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})/.exec(b.substring(c));if(null!==a&&0<a.length)return k.color=[parseInt(a[1],16),parseInt(a[2],16),parseInt(a[3],16),1],c+=a[0].length,!0;a=/^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])/.exec(b.substring(c));if(null!==a&&0<a.length)return k.color=[17*parseInt(a[1],16),17*parseInt(a[2],
    16),17*parseInt(a[3],16),1],c+=a[0].length,!0;a=/^rgb\(\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*\)/.exec(b.substring(c));if(null!==a&&0<a.length)return k.color=[parseInt(a[1],10),parseInt(a[2],10),parseInt(a[3],10),1],c+=a[0].length,!0;a=/^rgba\(\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*\)/.exec(b.substring(c));return null!==a&&0<a.length?(k.color=[parseInt(a[1],10),parseInt(a[2],10),parseInt(a[3],10),parseFloat(a[4])],c+=a[0].length,!0):!1}function f(){var a=/^\s+/.exec(b.substring(c));
    null!==a&&0<a.length&&(c+=a[0].length)}function g(){var a=/^\s*,\s*!/.exec(b.substring(c));return null!==a&&0<a.length?(c+=a[0].length,!0):!1}function e(a){if(h.isPlainObject(a)){var b,e,c=0,d=[];h.isArray(a.color)&&(e=a.color,c=e.length);for(b=0;4>b;b++)b<c?d.push(e[b]):3===b?d.push(1):d.push(0)}return h.extend({left:0,top:0,blur:0,spread:0},a)}for(var p=[],c=0,n=b.length,k=e();c<n;)if(m())f();else if(d())f();else if(l())f();else if(g())p.push(e(k)),k={};else break;p.push(e(k));return p}h.extend(!0,
    h,{support:{rgba:function(){var b=h("script:first"),m=b.css("color"),d=!1;if(/^rgba/.test(m))d=!0;else try{d=m!==b.css("color","rgba(0, 0, 0, 0.5)").css("color"),b.css("color",m)}catch(l){}b.removeAttr("style");return d}()}});var s=h("html").prop("style"),n;h.each(["boxShadow","MozBoxShadow","WebkitBoxShadow"],function(b,h){if("undefined"!==typeof s[h])return n=h,!1});n&&(h.Tween.propHooks.boxShadow={get:function(b){return h(b.elem).css(n)},set:function(b){var m=b.elem.style,d=q(h(b.elem)[0].style[n]||
    h(b.elem).css(n)),l=q(b.end),f=Math.max(d.length,l.length),g;for(g=0;g<f;g++)l[g]=h.extend({},d[g],l[g]),d[g]?"color"in d[g]&&!1!==h.isArray(d[g].color)||(d[g].color=l[g].color||[0,0,0,0]):d[g]=q("0 0 0 0 rgba(0,0,0,0)")[0];b.run=function(b){b=r(d,l,b);m[n]=b}}})});*/



/**!
 * @preserve Shadow animation 1.11
 * http://www.bitstorm.org/jquery/shadow-animation/
 * Copyright 2011, 2013 Edwin Martin
 * Contributors: Mark Carver, Xavier Lepretre and Jason Redding
 * Released under the MIT and GPL licenses.
 */

jQuery(function($, undefined) {
    /**
     * Check whether the browser supports RGBA color mode.
     *
     * Author Mehdi Kabab <http://pioupioum.fr>
     * @return {boolean} True if the browser support RGBA. False otherwise.
     */
    function isRGBACapable() {
        var $script = $('script:first'),
            color = $script.css('color'),
            result = false;
        if (/^rgba/.test(color)) {
            result = true;
        } else {
            try {
                result = (color !== $script.css('color', 'rgba(0, 0, 0, 0.5)').css('color'));
                $script.css('color', color);
            } catch (e) {
            }
        }
        $script.removeAttr('style');

        return result;
    }

    $.extend(true, $, {
        support: {
            'rgba': isRGBACapable()
        }
    });

    /*************************************/

    // First define which property to use
    var styles = $('html').prop('style');
    var boxShadowProperty;
    $.each(['boxShadow', 'MozBoxShadow', 'WebkitBoxShadow'], function(i, property) {
        var val = styles[property];
        if (typeof val !== 'undefined') {
            boxShadowProperty = property;
            return false;
        }
    });

    $.a = 'bbb';

    // Extend the animate-function
    if (boxShadowProperty) {

        $['Tween']['propHooks']['boxShadow'] = {
            get: function(tween) {
                return $(tween.elem).css(boxShadowProperty);
            },
            set: function(tween) {
                var style = tween.elem.style;
                var p_begin = parseShadows($(tween.elem)[0].style[boxShadowProperty] || $(tween.elem).css(boxShadowProperty));
                var p_end = parseShadows(tween.end);
                var maxShadowCount = Math.max(p_begin.length, p_end.length);
                var i;
                for(i = 0; i < maxShadowCount; i++) {
                    p_end[i] = $.extend({}, p_begin[i], p_end[i]);
                    if (p_begin[i]) {
                        if (!('color' in p_begin[i]) || $.isArray(p_begin[i].color) === false) {
                            p_begin[i].color = p_end[i].color || [0, 0, 0, 0];
                        }
                    } else {
                        p_begin[i] = parseShadows('0 0 0 0 rgba(0,0,0,0)')[0];
                    }
                }
                tween['run'] = function(progress) {
                    var rs = calculateShadows(p_begin, p_end, progress);
                    style[boxShadowProperty] = rs;
                };
            }
        };
    }

    // Calculate an in-between shadow.
    function calculateShadows(beginList, endList, pos) {
        var shadows = [];
        $.each(beginList, function(i) {
            var parts = [], begin = beginList[i], end = endList[i];

            if (begin.inset) {
                parts.push('inset');
            }
            if (typeof end.left !== 'undefined') {
                parts.push(parseFloat(begin.left + pos * (end.left - begin.left)) + 'px '
                    + parseFloat(begin.top + pos * (end.top - begin.top)) + 'px');
            }
            if (typeof end.blur !== 'undefined') {
                parts.push(parseFloat(begin.blur + pos * (end.blur - begin.blur)) + 'px');
            }
            if (typeof end.spread !== 'undefined') {
                parts.push(parseFloat(begin.spread + pos * (end.spread - begin.spread)) + 'px');
            }
            if (typeof end.color !== 'undefined') {
                var color = 'rgb' + ($.support['rgba'] ? 'a' : '') + '('
                    + parseInt((begin.color[0] + pos * (end.color[0] - begin.color[0])), 10) + ','
                    + parseInt((begin.color[1] + pos * (end.color[1] - begin.color[1])), 10) + ','
                    + parseInt((begin.color[2] + pos * (end.color[2] - begin.color[2])), 10);
                if ($.support['rgba']) {
                    color += ',' + parseFloat(begin.color[3] + pos * (end.color[3] - begin.color[3]));
                }
                color += ')';
                parts.push(color);
            }
            shadows.push(parts.join(' '));
        });
        return shadows.join(', ');
    }

    // Parse the shadow value and extract the values.
    function parseShadows(shadow) {
        var parsedShadows = [];
        var parsePosition = 0;
        var parseLength = shadow.length;

        function findInset() {
            var m = /^inset\b/.exec(shadow.substring(parsePosition));
            if (m !== null && m.length > 0) {
                parsedShadow.inset = true;
                parsePosition += m[0].length;
                return true;
            }
            return false;
        }
        function findOffsets() {
            var m = /^(-?[0-9\.]+)(?:px)?\s+(-?[0-9\.]+)(?:px)?(?:\s+(-?[0-9\.]+)(?:px)?)?(?:\s+(-?[0-9\.]+)(?:px)?)?/.exec(shadow.substring(parsePosition));
            if (m !== null && m.length > 0) {
                parsedShadow.left = parseInt(m[1], 10);
                parsedShadow.top = parseInt(m[2], 10);
                parsedShadow.blur = (m[3] ? parseInt(m[3], 10) : 0);
                parsedShadow.spread = (m[4] ? parseInt(m[4], 10) : 0);
                parsePosition += m[0].length;
                return true;
            }
            return false;
        }
        function findColor() {
            var m = /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})/.exec(shadow.substring(parsePosition));
            if (m !== null && m.length > 0) {
                parsedShadow.color = [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 1];
                parsePosition += m[0].length;
                return true;
            }
            m = /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])/.exec(shadow.substring(parsePosition));
            if (m !== null && m.length > 0) {
                parsedShadow.color = [parseInt(m[1], 16) * 17, parseInt(m[2], 16) * 17, parseInt(m[3], 16) * 17, 1];
                parsePosition += m[0].length;
                return true;
            }
            m = /^rgb\(\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*\)/.exec(shadow.substring(parsePosition));
            if (m !== null && m.length > 0) {
                parsedShadow.color = [parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), 1];
                parsePosition += m[0].length;
                return true;
            }
            m = /^rgba\(\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*\)/.exec(shadow.substring(parsePosition));
            if (m !== null && m.length > 0) {
                parsedShadow.color = [parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), parseFloat(m[4])];
                parsePosition += m[0].length;
                return true;
            }
            return false;
        }
        function findWhiteSpace() {
            var m = /^\s+/.exec(shadow.substring(parsePosition));
            if (m !== null && m.length > 0) {
                parsePosition += m[0].length;
                return true;
            }
            return false;
        }
        function findComma() {
            var m = /^\s*,\s*/.exec(shadow.substring(parsePosition));
            if (m !== null && m.length > 0) {
                parsePosition += m[0].length;
                return true;
            }
            return false;
        }
        function normalizeShadow(shadow) {
            if ($.isPlainObject(shadow)) {
                var i, sColor, cLength = 0, color = [];
                if ($.isArray(shadow.color)) {
                    sColor = shadow.color;
                    cLength = sColor.length;
                }
                for(i = 0; i < 4; i++) {
                    if (i < cLength) {
                        color.push(sColor[i]);
                    } else if (i === 3) {
                        color.push(1);
                    } else {
                        color.push(0);
                    }
                }
            }
            return $.extend({
                'left': 0,
                'top': 0,
                'blur': 0,
                'spread': 0
            }, shadow);
        }
        var parsedShadow = normalizeShadow();

        while (parsePosition < parseLength) {
            if (findInset()) {
                findWhiteSpace();
            } else if (findOffsets()) {
                findWhiteSpace();
            } else if (findColor()) {
                findWhiteSpace();
            } else if (findComma()) {
                parsedShadows.push(normalizeShadow(parsedShadow));
                parsedShadow = {};
            } else {
                break;
            }
        }
        parsedShadows.push(normalizeShadow(parsedShadow));
        return parsedShadows;
    }
});